#!/usr/bin/env perl
use strict;
use warnings;

package Putweet::Cache;
use parent qw/Cache::Memcached::Fast/;

sub new {
    my ($class, $args) = @_;
    my $self = $class->SUPER::new(+{
        servers   => [qw/127.0.0.1:11211/],
        namespace => 'putweet:',
    });
    return $self;
}

sub get_or_set {
    my ($self, $key, $sub, $expire) = @_;
    $expire ||= 0;

    my $value = $self->get($key);
    if (not defined $value) {
        $value = $sub->();
        if (defined $value) {
            $self->set($key => $value, $expire);
        }
    }
    return $value;
}

package Putweet;
use Class::Accessor::Lite (
    new => 1,
    rw  => [qw/
        dispatch menu nt term user user_list config count per last_updated statuses tl_types
        _blocking_users _followers _friends _user_info _list_memberships _favs cache
    /],
);
use Cache::Memory::Simple;
use Config::Pit qw/pit_get pit_set/;
use Clone qw/clone/;
use Data::Dumper qw/Dumper/;
use Encode qw/find_encoding is_utf8/;
use Furl;
use HTML::Entities qw/decode_entities/;
use JSON::XS ();
use Net::Twitter;
use Net::Twitter::Lite::WithAPIv1_1;
use String::Filter;
use Term::ANSIColor qw/colored/;
use Term::ReadKey qw/GetTerminalSize/;
use Term::ReadLine;
use Time::Piece;
use LWP::UserAgent;
use YAML::Syck qw/Load/;
use XML::Simple qw/XMLin/;

{
    package Data::Dumper;
    no warnings 'redefine';
    sub quote { return shift; }
}

$| = 1;
$XML::Simple::PREFERRED_PARSER = "XML::Parser";
$YAML::Syck::ImplicitUnicode = 1;

my $utf = find_encoding("utf-8");
sub utf { $utf }

my $furl = Furl->new;
sub furl { $furl }

my $ua = LWP::UserAgent->new(timeout => 3);
sub ua { $ua }

sub clear { system('clear') + 1 }

sub sayf {
    my ($format, @list) = @_;
    if (@list) {
        printf "$format\n", @list;
    } else {
        $format ||= "";
        print "$format\n";
    }
}

sub p {
    #local $Data::Dumper::Indent   = 1;
    local $Data::Dumper::Sortkeys = 1;
    local $Data::Dumper::Terse    = 1;
    local $Data::Dumper::Useperl = 1;

    warn Dumper \@_;
    $ENV{PT_DEBUG} or return;
    my @c = caller;
    print STDERR "  at $c[1]:$c[2]\n\n"
}

my @shorten_domains_ary = qw/
    buff.ly
    bit.ly
    htn.to
    feedly.com
    nico.ms
    t.co
    p.tl
/;
my %shorten_domains;
@shorten_domains{@shorten_domains_ary} = (1) x @shorten_domains_ary;

my $sf = String::Filter->new(
    rules => [
        '\@[a-zA-Z0-9_]+' => sub {
            my $screen_name = shift;
            return colored(["cyan"], $screen_name);
        },
        '#[^\s　]+' => sub {
            my $hashtag = shift;
            return colored(["blue"], $hashtag);
        },
    ]
);
my $sf_expand_url = String::Filter->new(
    rules => [
        'https?://[a-zA-Z0-9\.?/&]+' => sub {
            my $url = shift;
            $url = utf->encode($url);
            my $expand = $url;
            my ($domain) = $url =~ m{^https?://([a-zA-Z0-9\.]+)};
            while ($shorten_domains{$domain}) {
                $expand = expand_short_url($url);
                ($domain) = $expand =~ m{^https?://([a-zA-Z0-9\.]+)};
            }
            return $expand;
        },
    ]
);

sub parse_time {
    my $created_at = shift;
    my $utc = Time::Piece->strptime($created_at, '%a %b %d %H:%M:%S %z %Y');
    my $jst = localtime($utc->epoch);
    return $jst;
}

sub left {
    my ($length, $str) = @_;
    my $format = '%'. -$length . 's';
    return sprintf "$format", $str;
}

sub line {
    my $line = shift || "-";
    return $line x width();
}

sub width { (GetTerminalSize)[0] }

sub expand_short_url {
    my $url = shift;
    ua->head($url)->request->uri->as_string;
}

sub status_key { "status_$_[0]" }

my %DAY_MAP = qw/
    Mon 月
    Tue 火
    Wed 水
    Thu 木
    Fri 金
    Sat 土
    Sun 日
/;

my $HISTORY_FILE = "$ENV{HOME}/.putweet_history";

sub init {
    my ($self, @args) = @_;

    my $data = do {local $/ = undef; <main::DATA>};
    $data = Load $data;

    $self->init_accessor;
    $self->init_menu($data);
    $self->init_nt;

    my $user_list = pit_get('putweet_user_list');
    $self->user_list($user_list);

    open my $fh, "<", $HISTORY_FILE;
    for my $in (<$fh>) {
        chomp $in;
        $self->term->addhistory((split /;/, $in)[1]);
    }

    while (!$self->user) {
        $self->change_user;
    }
    return $self;
}
sub init_accessor {
    my ($self, $data) = @_;
    #$self->cache(Cache::Memory::Simple->new);
    $self->cache(Putweet::Cache->new);
    $self->config(+{});
    $self->dispatch(+{});
    $self->statuses(+{});
    $self->last_updated(+{});
    $self->tl_types([qw/home_timeline mentions retweets_of_me/]);#direct_messages favorites
    $self->statuses->{$_} = +{} for $self->tl_types_array;
    $self->count(20);
    $self->per(60 * 5);
    $self->term(Term::ReadLine->new(''));
}
sub init_menu {
    my ($self, $data) = @_;

    my $menu = sprintf "%s%s%s%s%s\n%%s\n", left(10, 'type'), left(5, 'key'), left(20, 'method'), left(21, 'args'), "explanation";

    my @menu_items = @{$data->{menu}->{item}};
    my $menu_contents = $data->{menu}->{contents};

    for (my $i = 0; $i < @menu_items; $i++) {
        $menu .= "$menu_items[$i]\n";
        for my $contents (@{$data->{menu}->{contents}->[$i]}) {
            my ($key, $method, $args, $explanation) = @$contents;
            $explanation ||= '';
            my $str = sprintf "%s%s%s%s%s\n", ' ' x 10, left(5, $key), left(20, $method), left(21, $args), $explanation;
            $menu .= $str;
            $self->dispatch->{$key} = $method;
        }
    }
    $self->menu($menu);
}
sub init_nt {
    my ($self, $data) = @_;
    my $c = pit_get('putweet');
    unless (%$c) {
        clear;
        sayf "there is no putweet oauth info. input your application info to use as an alternative." and sayf;
        my $consumer_key    = $self->term->readline('consumer_key :');
        my $consumer_secret = $self->term->readline('consumer_secret :');
        my $traits = [qw/API::Lists API::REST API::Search OAuth/];
        $c = {
            consumer_key => $consumer_key,
            consumer_secret => $consumer_secret,
            traits => $traits,
        };
        my $nt = Net::Twitter::Lite::WithAPIv1_1->new(%$c);

        sayf "\ngo to the url, and input PIN you got.\n\n%s\n", $nt->get_authorization_url;

        my $pin = $self->term->readline('pin :');
        my ($access_token, $access_token_secret, $user_id, $screen_name) = $nt->request_access_token(verifier => $pin);
        my $putweet_user = [
            +{
                screen_name => $screen_name,
                access_token => $access_token,
                access_token_secret => $access_token_secret,
                config => {
                    expand_url         => 0,
                    tweetable          => 1,
                    show_main_menu     => 1,
                    show_react_menu    => 1,
                    show_client_source => 0,
                },
            },
        ];

        pit_set("putweet", data => $c);
        pit_set("putweet_user_list", data => $putweet_user);

        ### OBSOLETE: basic auth
        #my $username = $self->term->readline('username? :');
        #my $password = $self->term->readline('password? :');
        ## I am not as kind as use Term::ReadPassword
        #$self->user($username);
        #my %c = (
        #    traits   => [qw/API::Lists API::REST API::Search/],
        #    username => $username,
        #    password => $password,
        #);
        #return $self->nt(Net::Twitter::Lite::WithAPIv1_1->new(%c));
    }
    $self->nt(Net::Twitter::Lite::WithAPIv1_1->new(%$c));
    $self->nt(Net::Twitter->new($c));
}

sub fix_source {
    my ($self, $source) = @_;
    $source ||= "";
    my $source_url = "";

    if ($source) {
        $source = decode_entities $source;
        $source =~ m{<.*?href="(.*?)".*?>(.+)</a>} and $source_url = $1 and $source = $2;
        $source_url and $self->config->{show_client_source} and $source .= " $source_url";
        $source = "via $source";
        $source = utf->encode($source) if is_utf8($source);
    }
    return ($source, $source_url);
}

sub expand_entities {
    my ($self, $status) = @_;

    my $entities = $status->{entities};
    if (my $medias = $entities->{media}) {
        for my $media (@$medias) {
            $status->{text} =~ s/\Q$media->{url}\E/$media->{expanded_url}/;
        }
    }
    else {
        my $urls = $entities->{urls};
        for my $url (@$urls) {
            $status->{text} =~ s/\Q$url->{url}\E/$url->{expanded_url}/;
        }
    }
    return $status;
}

sub passed {
    my ($self, $type, $screen_name) = @_;
    $screen_name ||= $self->user;

    my $ret;

    if (ref $self->last_updated->{$type}->{$screen_name}) {
        my $diff = (scalar localtime) - $self->last_updated->{$type}->{$screen_name};
        $ret = ($diff->seconds < $self->per) ? 0 : 1;
    }
    else {
        $ret = 1;
    }

    $ret;
}

sub tl_types_array {
    my ($self) = @_;
    @{$self->tl_types}
}

sub show_menu {
    my ($self) = @_;
    sayf $self->menu, "=" x width;
}

sub init_statuses {
    my $self = shift;

    my %tl_opt = (
        favorites => +{id => $self->user},
    );
    for my $tl_name ($self->tl_types_array) {
        my $opt = $tl_opt{$tl_name} || +{};
        $opt = +{
            %$opt,
            include_rts => 1,
            include_entities => 1,
        };
        my $statuses = $self->nt->$tl_name($opt);
        for my $status (@$statuses) {
            my ($source, $source_url) = $self->fix_source($status->{source});
            $source =~ m/^via twittbot\.net$/ and next; # spam
            $status->{id} or next;# sometimes api return blank data
            #$status->{user}->{screen_name} eq "span" and next;
            $status = $self->expand_entities($status);
            $self->statuses->{$tl_name}->{$status->{id}} = $status;
        }
        sayf "got $tl_name";
    }
    sayf "update!";
    $self->last_updated->{basic}->{$self->user} = scalar localtime;
}

sub update_statuses {
    my ($self) = @_;
    $self->passed("basic") or return;

    $self->init_statuses;
}

sub clear_statuses {
    my ($self) = @_;

    $self->$_(+{}) for qw/statuses last_updated/;
    $self->cache->flush_all;
    $self->done("clear !");
}

sub run {
    my ($self) = @_;

    while (1) {
        $self->last_updated->{basic}->{$self->user} ||= ((scalar localtime) - 60 * 10);
        clear;
        sayf "login as: %s  last update: %s\n", $self->user, $self->last_updated->{basic}->{$self->user}->hms;
        $self->config->{show_main_menu} and $self->show_menu;

        if (defined (my $input = $self->term->readline('putweet: '))) {
            my @args = split / /, $input;

            if (@args and my $func = $self->dispatch->{shift @args}) {
                if (length $input > 1) {
                    $self->record_history(+{input => $input});
                }

                eval { $self->$func(@args) };
                if ($@) {
                    sayf $@;
                    $self->done("error.");
                }
            }
        }
    }
}

sub record_history {
    my ($self, $args) = @_;
    my $input = $args->{input} or return;
    my @split = grep { $_ } split /\s+/, $input;
    my $command = join " ", @split;

    (my $dt = localtime->datetime) =~ s/T/ /;
    open my $fh, ">>", $HISTORY_FILE;
    print $fh "$dt;$command\n";
}

sub done {
    my ($self, $message) = @_;

    sayf $message || "";
    $self->term->readline("done.");
}

sub block_user {
    my ($self, $screen_name) = @_;
    return $self->done("args: user_id/screen_name.") unless $screen_name;
    $self->confirm($screen_name) or return;
    $self->nt->create_block($screen_name);
    $self->done("block: $screen_name");
}

sub unblock_user {
    my ($self, $screen_name) = @_;
    return $self->done("args: user_id/screen_name.") unless $screen_name;
    $self->nt->destroy_block($screen_name);
    $self->done("unblock: $screen_name");
}

sub show_blocking {
    my $self = shift;

    sayf $self->_blocking_users and return $self->done if $self->_blocking_users;
    my $bloking_users;
    my $users = $self->nt->blocking;
    for my $user (@{$users->{users}}) {
        my ($user_id, $screen_name, $name) = ($user->{id}, $user->{screen_name}, $user->{name});
        $name = utf->encode($name) if is_utf8($name);
        $bloking_users .= sprintf "%-9s %s\t%s\n", $user_id, $screen_name, $name;
    }
    $self->_blocking_users($bloking_users);
    sayf $self->_blocking_users and return $self->done;
}

sub report_spam {
    my ($self, $screen_name) = @_;
    return $self->done("args: id/screen_name") unless $screen_name;
    $self->confirm($screen_name) or return;
    $self->nt->report_spam($screen_name);
    $self->done("report spam and block: $screen_name");
}

sub change_user {
    my ($self, $error) = @_;
    return $self->done("you can't do this.") unless $self->user_list;

    clear and $error and sayf $error;

    my $i = 1;
    for my $user (@{$self->user_list}) {
        sayf '%d: %s', $i++, $user->{screen_name};
    }
    sayf;
    $i = $self->term->readline("which user?: ");
    $i =~ /^\d+$/ and $i-- or return $self->done("input error.");
    my @screen_names = map {$_->{screen_name}} @{$self->user_list};
    my $user = $screen_names[$i];

    my $current_user = $self->user_list->[$i] or return $self->done("input error.");
    $self->nt->access_token($current_user->{access_token});
    $self->nt->access_token_secret($current_user->{access_token_secret});
    $self->user($user);
    $self->config($current_user->{config});
    #$self->config(+{%{$current_user->{config}}});
    $self->$_(undef) for qw/_blocking_users _user_info _favs/;
    $self->$_(+{}) for qw/_followers _friends _list_memberships/;
    $self->last_updated->{basic}->{$self->user} = 0;
    #$self->statuses->{$_} = +{} for $self->tl_types_array;
    #$self->clear_statuses; #when user change
    $self->cache->flush_all;
    sayf 'getting statuses...';
    #$self->init_statuses;

    $self->done("user: $user");
}

sub destroy_status {
    my ($self, $args) = @_;
    $args or return $self->done('args: status_id[,status_id|-status_id]');

    if (ref $args) {
        my @ids = @$args;
        sayf '-%s', utf->encode($self->statuses->{user_timeline}->{$self->user}->{$_}->{text}) for @ids;

        $self->confirm("delete these ?") or return;

        for my $id (@ids) {
            $self->nt->destroy_status({id => $id});
            sayf "destroy_status(%s)", utf->encode($self->statuses->{user_timeline}->{$self->user}->{$id}->{text});
            delete $self->statuses->{user_timeline}->{$self->user}->{$id};
        }
    }
    else {
        my $id = $args;
        my $status = $self->statuses->{user_timeline}->{$self->user}->{$id};
        $status->{user}{screen_name} eq $self->user or return $self->done("the status is not yours");

        $self->confirm(utf->encode($status->{text})) or return;

        $self->nt->destroy_status({id => $id});
        delete $self->statuses->{user_timeline}->{$self->user}->{$id};
    }

    $self->last_updated->{user_timeline}->{$self->user} = undef if ! keys %{$self->statuses->{user_timeline}->{$self->user}};

    $self->done;
}

sub _show_status {
    my ($self, $status_id) = @_;

    my $status = $self->cache->get_or_set(
        status_key($status_id), sub {
            eval { $self->nt->show_status({id => $status_id, include_entities => 1}); };
        }
    );

    if ($@) {
        sayf "can not get tweet id=%d", $status_id;
        return;
    } else {
        return $status;
    }
}

sub show_status {
    my ($self, $id) = @_;
    $id or return $self->done('args: status id');

    my $status = $self->_show_status($id) or return;
    $status = $self->expand_entities($status);
    $self->statuses->{user_timeline}->{$status->{user}{screen_name}}->{$id} = $status;
    $self->print_status([$status]);
    $self->ask_reaction([$status]);
}

sub direct_messages {
    my ($self, $count) = @_;
    $count ||= $self->count;

    $self->update_statuses;
    my $statuses = $self->statuses->{direct_messages};
    $statuses = [map {$statuses->{$_}} sort {$b <=> $a} keys %$statuses];
    $self->print_status($statuses) and $self->done;
}

sub create_friend {
    my ($self, $screen_name) = @_;
    $screen_name or return $self->done('args: id/screen_name');

    $self->nt->create_friend(+{screen_name => $screen_name});
    $self->done("now following $screen_name.");
}

sub destroy_friend {
    my ($self, $screen_name) = @_;
    $screen_name or return $self->done('args: id/screen_name');
    $self->confirm($screen_name) or return;

    $self->nt->destroy_friend(+{screen_name => $screen_name});
    $self->done("destroy friendship $screen_name.");
}

sub rel_exists {
    my ($self, $id1, $id2) = @_;
    $id1 or return $self->done('args: screen_name{1,2}');
    $id2 or do { $id2 = $id1; $id1 = $self->user; };

    my $res1 = $self->nt->show_friendship(+{source_screen_name => $id1, target_screen_name => $id2});
    my $res2 = $self->nt->show_friendship(+{source_screen_name => $id2, target_screen_name => $id1});
    my $bool1 = $res1->{relationship}->{source}->{following} == JSON::XS::true ? 1 : 0;
    my $bool2 = $res2->{relationship}->{source}->{following} == JSON::XS::true ? 1 : 0;
    my %rel = (0 => 'NOT ', 1 => '');

    sayf '%s %sfollowing %s', $id1, $rel{$bool1}, $id2;
    sayf '%s %sfollowing %s', $id2, $rel{$bool2}, $id1;
    $self->done;
}

sub home_timeline {
    my ($self, $count) = @_;
    $count ||= $self->count;

    $self->update_statuses;
    my $statuses = $self->statuses->{home_timeline};
    $statuses = [map {$statuses->{$_}} sort {$b <=> $a} keys %$statuses];
    $self->print_status($statuses);
    $self->ask_reaction($statuses);
}

sub mentions {
    my ($self, $count) = @_;
    $count ||= $self->count;

    $self->update_statuses;
    my $statuses = $self->statuses->{mentions};
    $statuses = [map {$statuses->{$_}} sort {$b <=> $a} keys %$statuses];
    $self->print_status($statuses);
    $self->ask_reaction($statuses);
}

sub update {
    my ($self, @args) = @_;
    $args[0] or $self->done('args: status');

    unless ($self->config->{tweetable}) {
        sayf "you are not tweetable." and return $self->done;
    }
    my $post_param;
    if ($args[0] =~ m/^\d+$/) {
        $post_param->{in_reply_to_status_id} = shift @args;
    }

    my $status = join " ", @args;
    my $_status = utf->decode($status);
    if (140 < length $_status) {
        sayf "status cut 140 chars.";
        $status = substr($_status, 0, 140);
        $status = utf->encode($status);
    }
    $post_param->{status} = utf->decode($status);
    sayf "status: $status";
    sayf "length: ". length utf->decode($status);
    sayf;

    $self->nt->update($post_param) if $self->term->readline("ok? (y/n): ") eq 'y';
    $self->done;
}

sub new_direct_message {
    my ($self, @args) = @_;
    my $screen_name = shift @args;
    my $text = join " ", @args;
    $screen_name and $text or $self->done('args: screen_name, text');
    $self->confirm("$screen_name: $text");
    $self->nt->new_direct_message($screen_name, utf->decode($text));
    $self->done("send done");
}

sub user_timeline {
    my ($self, $screen_name, $count, $page, $max_id, $show_only_new) = @_;
    $screen_name ||= $self->user;
    $count       ||= $self->count;
    $page        ||= 0;
    $max_id      ||= 0;

    my ($statuses, %new_tweets);
    if ($max_id or $self->passed(user_timeline => $screen_name)) {
        $statuses = $self->nt->user_timeline({
            screen_name => $screen_name, count => $count, include_rts => 1, include_entities => 1,
            ($page ? (page => $page) : ()), ($max_id ? (max_id => $max_id) : ()),
        });
        for my $status (@$statuses) {
            $status = $self->expand_entities($status);
            $self->statuses->{user_timeline}->{$screen_name}->{$status->{id}} = $status;
            $new_tweets{$status->{id}} = $status;
        }
        $self->last_updated->{user_timeline}->{$screen_name} = scalar localtime if @$statuses;
    }

    if ($show_only_new) {
        $statuses = \%new_tweets;
    } else {
        $statuses = $self->statuses->{user_timeline}->{$screen_name};
    }
    $statuses = [map {$statuses->{$_}} sort {$b <=> $a} keys %$statuses];
    $self->print_status($statuses);
    $self->ask_reaction($statuses);
}

sub print_status {
    my ($self, $statuses, $opt) = @_;

    @$statuses = reverse @$statuses;
    my $i = @$statuses;
    for my $status (@$statuses) {
        my $org_status;
        my $verified = $status->{user}{verified} ? sprintf '(%s)', colored(["bright_magenta"], 'verified') : '';
        if ($status->{retweeted_status}) {
            $org_status = clone $status;
            $org_status = $self->expand_entities($org_status);
            $status = clone $status->{retweeted_status};
            $status = $self->expand_entities($status);
            delete $org_status->{retweeted_status};
            $status->{org_status} = $org_status;
        }
        my ($source, $source_url) = $self->fix_source($status->{source});

        my $reply_to = ($status->{in_reply_to_status_id} and $status->{in_reply_to_screen_name}) ?
            colored(["cyan"], "in reply to $status->{in_reply_to_screen_name}") : '';

        $status->{text} = $sf->filter($status->{text});
        $status->{text} = $sf_expand_url->filter($status->{text}) if $self->config->{expand_url};

        my $t = parse_time($status->{created_at});
        my $num = sprintf '%2d', $i;

        my $_screen_name = ($status->{user}{screen_name} or $status->{sender}{screen_name} or $status->{from_user});
        my $user_name = ($status->{user}{name} or $status->{sender}{name} or '');
        $user_name and $user_name = utf->encode($user_name);
        $_screen_name = sprintf '%s %s', $user_name, $_screen_name = colored(["cyan"], '@'.$_screen_name);
        if ($org_status) {
            #$_screen_name = colored(["green"], $_screen_name);
            my $_verified = $status->{user}{verified} ? sprintf '(%s)', colored(["bright_magenta"], 'verified') : '';
            $_screen_name .= $_verified;
            my $rt = colored(["green"], "RT");
            my $org_screen_name = colored(["cyan"], '@'.$org_status->{user}{screen_name});
            $_screen_name .= " ($rt:$org_screen_name)";
            $status->{text} =~ s/^RT @.+?//;
            $verified = $org_status->{user}{verified} ? sprintf '(%s)', colored(["bright_magenta"], 'verified') : '';
        }
        $_screen_name .= $verified;
        my $retweet_count = $status->{retweet_count} ? colored(["green"], "($status->{retweet_count} Retweeted)") : "";
        my $favorite_count = $status->{favorite_count} ? colored(["red"], "($status->{favorite_count} Favs)") : "";

        my $output = join " ", grep {$_}
            "[$num]", $t->ymd('/'), "($DAY_MAP{$t->day})", $t->hms,
            $_screen_name,
            $source, $reply_to, $retweet_count, $favorite_count;
        $output =~ s/\r?\n//g;

        sayf '%s%s%s%s%s', line("="), "\n", $output, "\n\n", decode_entities utf->encode($status->{text});

        $i--;
    }
    sayf line("=");
}

sub ask_reaction {
    my @caller = caller;
    my ($self, $statuses) = @_;

    if ($self->config->{show_react_menu}) {
        sayf and sayf join "\n",
            "-" x width,
            "  [number] : reply",
            " w[number] : show user's info",
            " R[number] : RT (official)",
            " r[number] : RT (unofficial)",
            " t[number] : RT (unofficial and without in_reply_to_status_id)",
            " T[number] : show official RTed users",
            " f[number] : follow time line",
            " e[number] : favorite the status",
            " s[number] : show user's timeline",
            " n[number] : report for spam",
            " b[number] : block user",
            " d[number] : delete your status",
            " x[number] : show relation between the user",
            " u[number] : show permalink the tweet",
            " a[number] : show the tweet",
            " c[number] : show tweets older the one",
            "  [other]  : end",
            "-" x width;
    }

    sayf;
    my $in = $self->term->readline('input: ');
    sayf;

    if (!$in) {
        return $self->done;
    }

    my ($c, $n);
    $in =~ /^([a-zA-Z0-9])([\d,\-]+)$/;
    $c = $1 || "";
    $n = $2 || "";

    if ($in =~ /^(\d+)$/) {
        $c = '';
        $n = $1;
    }
    my $status;

    if ($n =~ /^\d+$/) {
        $statuses->[$n * -1] or return $self->done("invalid input.");
        $n *= -1;
        $status = $statuses->[$n];
    }

    if ($n and !$c) {
        sayf "reply to: \@$status->{user}{screen_name}: " . utf->encode(decode_entities $status->{text});
        my $text = $self->term->readline('@' . $status->{user}{screen_name} . ' ');
        $text = "\@$status->{user}{screen_name} $text";
        $self->update($status->{id}, $text);
    }
    elsif ($c eq "w") {
        my $screen_name = $status->{from_user} || $status->{user}{screen_name};
        $self->record_history(+{input => "w $screen_name"});
        $self->show_user($screen_name);
    }
    elsif ($c eq "R") {
        my $id = $status->{id};
        $self->retweet($id);
    }
    elsif ($c eq "r" or $c eq "t") {
        sayf $c eq 'r' ? 'with in_reply_to_status_id' : 'without in_reply_to_status_id';
        sayf "RT to: \@$status->{user}{screen_name}: " . utf->encode($status->{text});
        my $text = $self->term->readline('str: ');
        $text = sprintf '%s RT @%s ', $text, utf->encode("$status->{user}{screen_name}: $status->{text}");
        $c eq 't' ? $self->update($text) : $self->update($status->{id}, $text);
    }
    elsif ($c eq "T") {
        my $id = $status->{id};
        my $retweeters_ids = $self->nt->retweeters_ids($id);
        for my $i (@{$retweeters_ids->{ids}}) {
            my $user = $self->nt->show_user(+{id => $i});
            sayf $user->{screen_name};
        }
    }
    elsif ($c eq "f") {
        clear;
        my $reply_id = $status->{in_reply_to_status_id};
        if ($reply_id) {
            $self->record_history(+{input => sprintf('a %d # %s', $status->{id}, $status->{user}{screen_name})});
            print "getting tweets ";
            my @follow_statuses = ($status);
            while ($reply_id) {
                my $parent_status = $self->_show_status($reply_id) or last;
                $parent_status = $self->expand_entities($parent_status);
                push @follow_statuses, $parent_status;
                $self->record_history(+{input => sprintf('a %d # %s', $reply_id, $parent_status->{user}{screen_name})});
                print ".";
                $reply_id = $parent_status->{in_reply_to_status_id} or 0;
            }
            sayf;
            $self->print_status(\@follow_statuses);
            return $self->ask_reaction(\@follow_statuses);
        }
        else {
            sayf "can not follow. there is no 'in_reply_to_status_id'";
        }
    }
    elsif ($c eq "e") {
        my $id = $status->{id};
        my $screen_name = $status->{from_user} || $status->{user}{screen_name};
        my $text = utf->encode($status->{text});
        $self->nt->create_favorite($id) and return $self->done("favorite:\n$screen_name\:$text");
    }
    elsif ($c eq "s") {
        my $screen_name = $status->{from_user} || $status->{user}{screen_name};
        $self->record_history(+{input => "s $screen_name"});
        $self->user_timeline($screen_name);
    }
    elsif ($c eq "n") {
        my $screen_name = $status->{from_user} || $status->{user}{screen_name};
        $self->report_spam($screen_name);
    }
    elsif ($c eq "d") {
        if ($status) {
            my $id = $status->{id};
            $self->destroy_status($id);
        }
        elsif ($n) {
            my @ids;

            my @parts = split /,/, $n;
            for my $i (@parts) {
                if ($i =~ /^\d+$/) {
                    push @ids, $statuses->[$i * -1]->{id} if $statuses->[$i * -1]->{id};
                }
                elsif ($i =~ /^(\d+)-(\d+)$/) {
                    for my $id ($1 .. $2) {
                        push @ids, $statuses->[$id * -1]->{id};
                    }
                }
            }

            $self->destroy_status(\@ids);
        }
    }
    elsif ($c eq "b") {
        my $screen_name = $status->{from_user} || $status->{user}{screen_name};
        $self->block_user($screen_name);
    }
    elsif ($c eq "x") {
        $self->rel_exists($status->{user}{screen_name});
    }
    elsif ($c eq "u") {
        my $screen_name = $status->{from_user} || $status->{user}{screen_name};
        my $url = sprintf "https://twitter.com/%s/status/%d", $screen_name, $status->{id};
        sayf $url;
        my $input = sprintf 'a %d # %s', $status->{id}, $screen_name;
        $self->record_history(+{input => $input});
    }
    elsif ($c eq "a") {
        $self->show_status($status->{id});
    }
    elsif ($in eq "c") {
        $status = $statuses->[0];
        my $target = $status->{org_status} || $status;

        $self->user_timeline($target->{user}{screen_name}, 0, 0, ($target->{id} - 1), 1);
    }
}

sub confirm {
    my ($self, @value) = @_;
    my $method = (split /::/, (caller 1)[3])[-1];
    sayf "$method(@value)\n";
    $self->term->readline("do ok? (y/n): ") eq 'y';
}

sub show_user {
    my ($self, $id) = @_;
    defined $id or $id = $self->user;
    #say $self->_user_info->{body} and return $self->done
    #if $self->_user_info and $self->_user_info->{id} eq $id;

    my $key = $id =~ /^\d+$/ ? "id" : "screen_name";
    my %res = %{$self->nt->show_user(+{$key => $id})};
    my %filterd;
    my @want = qw/id name screen_name lang url description location time_zone
                  statuses_count created_at friends_count followers_count protected verified listed_count/;
    @filterd{@want} = @res{@want};
    my $t = parse_time($filterd{created_at});
    $filterd{created_at} = join " ", $t->ymd('/'), "(@{[$t->day]})", $t->hms;
    for my $key (qw/protected verified/) {
        if (JSON::XS::is_bool $filterd{$key}) {
            $filterd{$key} = $filterd{$key} == JSON::XS::true ? 1 : 0;
        }
        else {
            $filterd{$key} = $filterd{$key} ? 1 : 0;
        }
    }

    my %user_info;
    $user_info{id} = $id;
    for my $key (@want) {
        length $filterd{$key} or $filterd{$key} = '';
        $filterd{$key} =~ s/\r?\n/ /g;
        decode_entities $filterd{$key};

        my $s1 = 55;
        my $s2 = $s1 - 15;
        if ($s1 < (length $filterd{$key})) {
            no warnings;
            my $rest = substr $filterd{$key}, 0, $s2;
            $filterd{$key} = substr $filterd{$key}, $s2;
            $rest = utf->encode($rest) if is_utf8($rest);
            my $key2 = sprintf "%-15s", $key;
            $user_info{body} .= "$key2 $rest\n";
            while ($filterd{$key}) {
                $rest = substr $filterd{$key}, 0, $s1;
                $filterd{$key} = substr $filterd{$key}, $s1;
                $rest = utf->encode($rest) if is_utf8($rest);
                $user_info{body} .= " " x 16 . "$rest\n";
            }
        }
        else {
            $filterd{$key} = utf->encode($filterd{$key}) if $filterd{$key} and is_utf8($filterd{$key});
            $filterd{$key} = $sf->filter($filterd{$key});
            $filterd{$key} = $sf_expand_url->filter($filterd{$key}) if $self->config->{expand_url};

            my $key2 = sprintf "%-15s", $key;
            $user_info{body} .= "$key2 $filterd{$key}\n";
        }
    }
    sayf $user_info{body};
    $self->_user_info(\%user_info) if $id eq $self->user;
    $self->done;
}

sub retweet {
    my ($self, $id) = @_;
    $id or return $self->done('args: status id');

    my $status = $self->cache->get_or_set(
        status_key($id), sub {
            $self->nt->show_status({id => $id, include_entities => 1});
        }
    );
    $self->print_status([$status]);
    $self->confirm("do official retweet ?") or return $self->done;
    $self->nt->retweet($id);
    $self->done;
}

sub followers {
    my ($self, $screen_name) = @_;
    $screen_name ||= $self->user;

    sayf $self->_followers->{$screen_name} and return $self->done if $self->_followers->{$screen_name};

    my $followers = join "\n", map { " $_->{screen_name}" } reverse @{$self->nt->followers({screen_name => $screen_name})->{users}};
    $self->_followers->{$screen_name} = $followers;
    sayf "$screen_name followers";
    sayf $self->_followers->{$screen_name} and return $self->done;
}

sub friends {
    my ($self, $screen_name) = @_;
    $screen_name ||= $self->user;

    sayf $self->_friends->{$screen_name} and return $self->done if $self->_friends->{$screen_name};

    my $friends = join "\n", map { " $_->{screen_name}" } reverse @{$self->nt->friends({screen_name => $screen_name})->{users}};
    $self->_friends->{$screen_name} = $friends;
    sayf "$screen_name following";
    sayf $self->_friends->{$screen_name} and return $self->done;
}

sub retweets_of_me {
    my ($self, $count) = @_;
    $count ||= $self->count;

    $self->update_statuses;
    my $statuses = $self->statuses->{retweets_of_me};
    $statuses = [map {$statuses->{$_}} sort {$b <=> $a} keys %$statuses];
    $self->print_status($statuses) and $self->done;
}

sub retweeted_by_user {
    my ($self, $screen_name, $count, $page) = @_;
    $screen_name ||= $self->user;
    $count ||= $self->count;
    $page  ||= 0;

    my $statuses;
    if ($self->passed(retweeted_by_user => $screen_name)) {
        $statuses = $self->nt->retweeted_by_user({
            screen_name => $screen_name, count => $count, include_entities => 1,
            page => $page,
        });
        for my $status (@$statuses) {
            $status = $self->expand_entities($status);
            $self->statuses->{retweeted_by_user}->{$screen_name}->{$status->{id}} = $status;
        }
        $self->last_updated->{retweeted_by_user}->{$screen_name} = scalar localtime;
    }
    $statuses = $self->statuses->{retweeted_by_user}->{$screen_name};
    $statuses = [map {$statuses->{$_}} sort {$b <=> $a} keys %$statuses];
    $self->print_status($statuses);
    $self->ask_reaction($statuses);
}

sub list_memberships {
    my ($self, $screen_name) = @_;
    $screen_name ||= $self->user;
    sayf $self->_list_memberships->{$screen_name} and return $self->done
        if $self->_list_memberships->{$screen_name};

    my $lists = $self->nt->list_memberships({user => $screen_name, cursor => -1});
    my ($_list_memberships, @list_memberships);

    my $i = 1;
    do {
        for my $list (@{$lists->{lists}}) {
            my $str = $list->{description} || '';
            $str = utf->encode($str) if is_utf8($str);
            $list->{full_name} = utf->encode($list->{full_name}) if is_utf8($list->{full_name});
            push @list_memberships, "$list->{full_name} :$str\n";
        }
        my $lists_next = $self->nt->list_memberships({user => $screen_name, cursor => $lists->{next_cursor}});
        $lists = $lists->{next_cursor} ? $lists_next : undef;
    } while $lists;

    $_list_memberships .= "list number: " . @list_memberships . "\n\n";
    $_list_memberships .= $_ for @list_memberships;
    $self->_list_memberships->{$screen_name} = ($_list_memberships);
    sayf $self->_list_memberships->{$screen_name} and return $self->done;
}

sub all_lists {
    my ($self, $screen_name) = @_;
    $screen_name ||= $self->user;

    my $lists = $self->nt->get_lists({screen_name => $screen_name});
    for my $list (@$lists) {
        sayf "- %s / %d", $list->{name}, $list->{id};
    }
    return $self->done;
}

sub list_statuses {
    my ($self, $list_name, $screen_name, $count, $page, $max_id) = @_;
    $list_name or return $self->done('invalid args');
    $screen_name ||= $self->user;
    $count ||= $self->count;
    $page  ||= 0;
    $max_id ||= 0;

    my $statuses;
    if ($self->passed("list_$list_name" => $screen_name)) {
        $statuses = $self->nt->list_statuses({
            list_id => $list_name, owner_screen_name => $screen_name, count => $count, include_rts => 1, include_entities => 1,
            page => $page, ($max_id ? (max_id => $max_id) : ()),
        });
        for my $status (@$statuses) {
            $status = $self->expand_entities($status);
            $self->statuses->{"list_$list_name"}->{$screen_name}->{$status->{id}} = $status;
        }
        $self->last_updated->{"list_$list_name"}->{$screen_name} = scalar localtime if @$statuses;
    }
    $statuses = $self->statuses->{"list_$list_name"}->{$screen_name};
    $statuses = [map {$statuses->{$_}} sort {$b <=> $a} keys %$statuses];
    $self->print_status($statuses);
    $self->ask_reaction($statuses);
}

sub search {
    my ($self, @words) = @_;
    @words or return $self->done('args: word[s]');
    @words = map { s/　/ /g; /^-/ ? $_ : qq{"$_"}; } @words;

    my @ng_words = do {
        my $ng_words = "$ENV{HOME}/.putweet_ng_words";
        my @spam = map {qq{-source:$_}} qw/twittbot.net twiroboJP autotweety.net/; # max 3? want to add 'Tweet Old Post'
        my @w = (
            "exclude:retweets",
            @spam,
        );

        if (open my $fh_ng, "<", $ng_words) {
            for my $i (<$fh_ng>) {
                chomp $i;
                if ($i =~ /^exclude:/) {
                    push @w, "$i";
                } else {
                    push @w, "-$i";
                }
            }
        }

        @w;
    };
    my $word = join " ", @words, @ng_words;
    $word = utf->decode($word);
    my $statuses = $self->nt->search({q => $word, lang => 'ja', include_entities => 1})->{statuses};
    for my $status (@$statuses) {
        $status = $self->expand_entities($status);
    }
    $self->print_status($statuses, 1);
    $self->ask_reaction($statuses);
}

sub saved_searches_list {
    my ($self, ) = @_;
    my $saved = $self->cache->get_or_set(
        saved_searches => sub { $self->nt->saved_searches }, 60*60
    );
    for (my $i=0; $i<@$saved; $i++) {
        my $datum = $saved->[$i];
        sayf "%d: %s", $i, utf->encode($datum->{name});
        sayf line("=");
    }
    my $input = $self->term->readline('search num ? ');
    length $input or return $self->done;
    if (my $datum = $saved->[$input]) {
        my $statuses = $self->nt->search({q => $datum->{query}, lang => 'ja', include_entities => 1})->{statuses};
        for my $status (@$statuses) {
            $status = $self->expand_entities($status);
        }
        $self->print_status($statuses, 1);
        $self->ask_reaction($statuses);
    } else {
        $self->done;
    }
}

sub favorites {
    my ($self, $screen_name) = @_;

    my $statuses;
    if ($screen_name) {
        $statuses = $self->nt->favorites({screen_name => $screen_name});
    } else {
        $screen_name = $self->user;
        $self->update_statuses;
        $statuses = $self->statuses->{favorites};
        $statuses = [map {$statuses->{$_}} sort {$b <=> $a} keys %$statuses];
    }
    $self->print_status($statuses);
    $self->ask_reaction($statuses);
}

# OBSOLETE
sub favorited {
    my ($self, $screen_name) = @_;
    $screen_name ||= $self->user;

    #sayf $self->_favs->{$screen_name} and $self->done
    #    if $self->_favs and $self->_favs->{$screen_name};

    my $favs;
    my $content = furl->get("http://ja.favstar.fm/users/$screen_name/rss")->content;
    length $content == 1 and return $self->done('seems protected.');
    my $xml = XMLin($content);

    my $item = $xml->{channel}->{item} or $self->done("no favorited tweets.");
    for my $i (reverse @$item) {
        my $str = decode_entities(utf->encode($i->{title}));
        $str =~ s/stars?/favs/;
        $favs .= "$str\n";
    }
    my $_favs = $self->_favs;
    $_favs->{$screen_name} = $favs;
    $self->_favs($_favs);
    sayf $self->_favs->{$screen_name} and $self->done;
}

sub change_config {
    my ($self, $item, $value) = @_;

    if ($item) {
        if (defined $value) {
            sayf "$item -> $value";
            $self->config->{$item} = $value;
        }
        else {
            delete $self->config->{$item};
        }

        my $user_list = $self->user_list;
        my $i = 0;
        while (1) {
            if ($user_list->[$i++]->{screen_name} eq $self->user) {
                last;
            }
        }
        $user_list->[$i]->{config} = $self->config;
        pit_set("putweet_user_list", data => $user_list);
        $self->done('configed.');
    }
    else {
        sayf "your config";
        p $self->config;
        $self->done;
    }
}

sub quit {
    my ($self, @args) = @_;
    $self->cache->flush_all;
    sayf "bye." and exit
}

package main;
Putweet->new->init->run;

__DATA__
menu:
  item:
    - timeline
    - status
    - user
    - message
    - friend
    - block
    - lists
    - favorites
    - search
    - system
  contents:
    -
      -
        - f
        - home_timeline
        - count?
        - ~
      -
        - m
        - mentions
        - count?
        - ~
      -
        - s
        - user_timeline
        - user_id/screen_name
        - show one user's timeline
      -
        - t
        - retweets_of_me
        - count?
        - show your RTed status
      -
        - T
        - retweeted_by_user
        - screen_name?
        - show one user's RT
    -
      -
        - a
        - show_status
        - status_id
        - show the id's status
      -
        - y
        - destroy_status
        - status_id
        - ~
      -
        - u
        - update
        - status
        - ~
      -
        - D
        - new_direct_message
        - screen_name, text
        - send direct message
    -
      -
        - i
        - friends
        - screen_name?
        - show your friends
      -
        - o
        - followers
        - screen_name?
        - show your followers
      -
        - w
        - show_user
        - user_id/screen_name?
        - show the user's info
    -
      -
        - d
        - direct_messages
        - count?
        - show your direct messages
    -
      -
        - e
        - create_friend
        - user_id/screen_name
        - ~
      -
        - r
        - destroy_friend
        - user_id/screen_name
        - ~
      -
        - x
        - rel_exists
        - screen_name{1,2}
        - ~
    -
      -
        - b
        - block_user
        - user_id/screen_name
        - ~
      -
        - k
        - unblock_user
        - user_id/screen_name
        - ~
      -
        - L
        - show_blocking
        - none
        - ~
      -
        - n
        - report_spam
        - user_id/screen_name
        - ~
    -
      -
        - p
        - list_memberships
        - none
        - ~
      -
        - S
        - all_lists
        - screen_name?
        - show user's lists
      -
        - E
        - list_statuses
        - list_id,screen_name?
        - show list timeline
    -
      -
        - g
        - favorites
        - screen_name?
        - show your favorites
    -
      -
        - z
        - search
        - word
        - search from tweets
      -
        - v
        - saved_searches_list
        - none
        - show saved_searches/list
    -
      -
        - c
        - change_user
        - none
        - ~
      -
        - C
        - change_config
        - item/value
        - ~
      -
        - l
        - clear_statuses
        - none
        - clear statuses cache
      -
        - q
        - quit
        - none
        - ~
