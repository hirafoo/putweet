#!/usr/bin/perl
package Putweet;
use base qw/Class::Accessor::Fast/;
use strict;
use warnings;
use Config::Pit qw/pit_get pit_set/;
use Data::Dumper;
use Encode qw/find_encoding/;
use HTML::Entities qw/decode_entities/;
use LWP::UserAgent;
use Net::Twitter;
use Term::ReadKey qw/GetTerminalSize/;
use Term::ReadLine;
use Time::Piece;
use YAML::Syck qw/Load/;
use XML::RSS;
$YAML::Syck::ImplicitUnicode = 1;

my ($COUNT, $PER) = (5, 300);
my (%STATUSES, $last_updated);
my @TL_TYPES = qw/home_timeline mentions retweets_of_me/;#direct_messages favorites
my $utf = find_encoding("utf-8");

__PACKAGE__->mk_accessors(qw/
    dispatch menu nt term user user_list tweetable
    _blocking_users _followers _friends _user_info _list_memberships _favs
/);

sub utf { $utf }
sub clear { system('clear') + 1 }
sub say { print @_, "\n" }
sub p {
    local $Data::Dumper::Indent = 1;
    local $Data::Dumper::Terse  = 1;
    warn Dumper shift
}
sub pp {
    warn Dumper @_;
    my @c = caller;
    print STDERR "  at $c[1]:$c[2]\n\n"
}
sub parse_time {
    my ($created_at, $opt) = @_;
    $opt ? (Time::Piece->strptime($created_at, '%a, %d %b %Y %H:%M:%S +0000') + 32400)
         : (Time::Piece->strptime($created_at, '%a %b %d %H:%M:%S +0000 %Y')  + 32400);
}
sub left {
    my ($length, $str) = @_;
    my $format = '%'. -$length . 's';
    sprintf "$format", $str
}

sub _passed {
    if (ref $last_updated) {
        my $now = localtime;
        my $diff = $now - $last_updated;
        ($diff->seconds < $PER) ? 0 : 1;
    }
    else {
        1
    }
}

sub new { bless {}, shift }

sub init {
    my ($self, @args) = @_;

    $self->dispatch({});
    $STATUSES{$_} = {} for (@TL_TYPES);

    my ($width) = GetTerminalSize;
    my $data = do {local $/ = undef; <main::DATA>};
    $data = Load $data;
    my $menu = left(10, 'type') . left(5, 'cmd') . left(18, 'method') . left(21, 'args') . "explanation\n";
    $menu .= "=" x $width . "\n";

    my @menu_items = @{$data->{menu}->{item}};
    my $menu_contents = $data->{menu}->{contents};

    for (my $i = 0; $i < @menu_items; $i++) {
        $menu .= "$menu_items[$i]\n";
        for my $contents (@{$data->{menu}->{contents}->[$i]}) {
            my ($cmd, $method, $args, $explanation) = @$contents;
            $explanation ||= '';
            my $str = ' ' x 10 . left(5, $cmd) . left(18, $method) . left(21, $args) . $explanation . "\n";
            $menu .= $str;
            $self->dispatch->{$cmd} = $method;
        }
    }
    $self->menu($menu);

    $self->term(Term::ReadLine->new(''));

    my $c = pit_get('putweet');
    unless (%$c) {
        clear;
        my $username = $self->term->readline('username? :');
        my $password = $self->term->readline('password? :');
        # I am not as kind as use Term::ReadPassword
        $self->user($username);
        my %c = (
            traits   => [qw/API::Lists API::REST API::Search/],
            username => $username,
            password => $password,
        );
        return $self->nt(Net::Twitter->new(%c));
    }
    $self->nt(Net::Twitter->new($c));

    my $user_list = pit_get('putweet_user_list');
    $self->user_list($user_list);

    $self->change_user;
}

sub init_statuses {
    my $self = shift;

    my %tl_opt = (
        favorites => +{id => $self->user},
    );
    for my $tl_name (@TL_TYPES) {
        my $opt = $tl_opt{$tl_name} || +{};
        my $statuses = $self->nt->$tl_name($opt);
        for my $status (@$statuses) {
            $status->{id} or next;# sometimes api return blank data
            $STATUSES{$tl_name}->{$status->{id}} = $status;
        }
        say "got $tl_name";
    }
    say "update!";
    $last_updated = localtime;
}

sub update_statuses {
    _passed or return;

    my ($self) = @_;
    $self->init_statuses;
}

sub main_loop {
    my ($self, @args) = @_;
    $last_updated or do {$last_updated = localtime; $last_updated -= 10 * 60};
    clear and say "now login as -> " . $self->user . "   last updated: ". $last_updated->hms and say;
    if (@args and my $func = $self->dispatch->{shift @args}) {
        $self->$func(@args);
    }
    else {
        say $self->menu;
    }
    my @in = split ' ', $self->term->readline('putweet ');
    $self->main_loop(@in);
}

sub done {
    my ($self, $message) = @_;

    $message ? say $message : say;
    my $done = $self->term->readline("done.");
    $self->main_loop;
}

sub block_user {
    my ($self, $screen_name) = @_;
    return $self->done("args: id/screen_name.") unless $screen_name;
    $self->nt->create_block($screen_name);
    $self->done("block: $screen_name");
}

sub unblock_user {
    my ($self, $screen_name) = @_;
    return $self->done("args: id/screen_name.") unless $screen_name;
    $self->nt->destroy_block($screen_name);
    $self->done("unblock: $screen_name");
}

sub show_blocking {
    my $self = shift;

    say $self->_blocking_users and return $self->done if $self->_blocking_users;
    my $bloking_users;
    my $users = $self->nt->blocking;
    for my $user (@$users) {
        my ($id, $name) = ((sprintf "%-9s", $user->{id}), $user->{screen_name});
        $bloking_users .= "$id $name\n";
    }
    $self->_blocking_users($bloking_users);
    say $self->_blocking_users and return $self->done;
}

sub report_spam {
    my ($self, $id) = @_;
    return $self->done("args: id/screen_name") unless $id;
    $self->nt->report_spam($id);
    $self->done("report spam and block: $id");
}

sub change_user {
    my ($self, $error) = @_;
    return $self->done("you can't do this.") unless $self->user_list;

    clear and $error and say $error;

    my $i = 1;
    for my $u (keys %{$self->user_list}) {
        say $i++ . ": $u";
    }
    say;
    $i = $self->term->readline("which user?: ");
    $i =~ /^\d+$/ and $i-- or return $self->change_user("input error.");
    my @user_list = %{$self->user_list};
    my $user = $user_list[$i * 2];

    my $c_user = $self->user_list->{$user} or return $self->change_user("input error.");
    $self->nt->access_token($c_user->{access_token});
    $self->nt->access_token_secret($c_user->{access_token_secret});
    $self->user($user);
    $self->tweetable($c_user->{tweetable});
    $self->$_(undef) for qw/_blocking_users _followers _friends _user_info _list_memberships/;
    undef $last_updated;
    $STATUSES{$_} = {} for (@TL_TYPES);
    say 'getting statuses. wait a moment...';
    #$self->init_statuses;
    $self->done("user: $user");
}

sub destroy_status {
    my ($self, $id) = @_;
    $id or return $self->done('args: status id');

    $self->nt->destroy_status({id => $id});
    $self->done;
}

sub show_status {
    my ($self, $id) = @_;
    $id or return $self->done('args: status id');

    my $status = $self->nt->show_status({id => $id});
    $self->print_status([$status]);
    $self->ask_reaction([$status]);
}

sub direct_messages {
    my ($self, $count) = @_;
    $count ||= $COUNT;

    $self->update_statuses;
    my $statuses = $STATUSES{direct_messages};
    $statuses = [map {$statuses->{$_}} reverse sort {$a <=> $b} keys %$statuses];
    $self->print_status($statuses) and $self->done;
}

sub create_friend {
    my ($self, $screen_name) = @_;
    $screen_name or return $self->done('args: id/screen_name');

    $self->nt->create_friend($screen_name);
    $self->done("now following $screen_name.");
}

sub destroy_friend {
    my ($self, $screen_name) = @_;
    $screen_name or return $self->done('args: id/screen_name');

    $self->nt->destroy_friend($screen_name);
    $self->done("destroy friendship $screen_name.");
}

sub rel_exists {
    my ($self, $id1, $id2) = @_;
    $id1 or return $self->done('args: screen_name{1,2}');
    $id2 or do { $id2 = $id1; $id1 = $self->user; };

    my $res1 = $self->nt->friendship_exists($id1, $id2);
    my $res2 = $self->nt->friendship_exists($id2, $id1);
    my %rel = (0 => 'NOT ', 1 => '');

    say "$id1 $rel{$res1}following $id2";
    say "$id2 $rel{$res2}following $id1";
    $self->done;
}

sub home_timeline {
    my ($self, $count) = @_;
    $count ||= $COUNT;

    $self->update_statuses;
    my $statuses = $STATUSES{home_timeline};
    $statuses = [map {$statuses->{$_}} reverse sort {$a <=> $b} keys %$statuses];
    $self->print_status($statuses);
    $self->ask_reaction($statuses);
}

sub mentions {
    my ($self, $count) = @_;
    $count ||= $COUNT;

    $self->update_statuses;
    my $statuses = $STATUSES{mentions};
    $statuses = [map {$statuses->{$_}} reverse sort {$a <=> $b} keys %$statuses];
    $self->print_status($statuses);
    $self->ask_reaction($statuses);
}

sub update {
    my ($self, @args) = @_;
    $args[0] or $self->done('args: status');

    unless ($self->tweetable) {
        say "you are not tweetable." and return $self->done;
    }
    my $post_param;
    if ($args[0] =~ m/^\d+$/) {
        $post_param->{in_reply_to_status_id} = shift @args;
    }

    my $status = join " ", @args;
    my $_status = utf->decode($status);
    if (140 < length $_status) {
        say "status cut 140 chars.";
        $status = substr($_status, 0, 140);
        $status = utf->encode($status);
    }
    $post_param->{status} = utf->decode($status);
    say "status: $status";

    $self->nt->update($post_param) if $self->term->readline("ok? (y/n): ") eq 'y';
    $self->done;
}

sub user_timeline {
    my ($self, $screen_name, $count) = @_;
    $screen_name or return $self->done('args: id/screen_name');
    $count ||= $COUNT;

    my $statuses = $self->nt->user_timeline({screen_name => $screen_name, count => $count});
    $self->print_status($statuses);
    $self->ask_reaction($statuses);
}

sub print_status {
    my ($self, $statuses, $opt) = @_;

    @$statuses = reverse @$statuses;
    my $i = 0;
    my ($width) = GetTerminalSize;
    my $line = "=" x $width;
    for my $status (@$statuses) {
        my $source = decode_entities $status->{source} || '';
        my $source_url;
        $source and $source =~ m{<.*?href="(.*?)".*?>(.+)</a>} and $source_url = $1 and $source = $2;
        $source and $source_url and $source .= " $source_url";
        $source and $source = "via $source";
        $source = utf->encode($source) if utf8::is_utf8($source);

        my $reply_to = $status->{in_reply_to_status_id};
        $reply_to = $reply_to ? "in reply to $status->{in_reply_to_screen_name}" : '';

        my $t = parse_time($status->{created_at}, $opt);
        my $num = sprintf '%2d', $i;

        say $line;
        say join " ",
        "[$num]", $t->ymd('/'), "(@{[$t->day]})", $t->hms,
        ($status->{user}{screen_name} or $status->{sender}{screen_name} or $status->{from_user}),
        $status->{id}, "$source $reply_to";
        say;
        say decode_entities utf->encode($status->{text});

        $i++;
    }
    say $line;
}

sub ask_reaction {
    my ($self, $statuses) = @_;

    say;
    say join "\n", 
    "---------------------------",
    "  [number] : reply",
    " w[number] : show user's info",
    " r[number] : RT (unofficial)",
    " t[number] : RT (unofficial and without in_reply_to_status_id)",
    " f[number] : follow time line",
    " v[number] : favorite the status",
    " s[number] : show user's timeline",
    " n[number] : report for spam",
    " b[number] : block user",
    " d[number] : delete your status",
    "  [other]  : end",
    "---------------------------";
    say;

    my $in = $self->term->readline('input: ');
    if ($in =~ m/^\d+$/ and $statuses->[$in]) {
        say "reply to: \@$statuses->[$in]->{user}{screen_name}: " . utf->encode(decode_entities $statuses->[$in]->{text});
        my $status = $self->term->readline('@' . $statuses->[$in]->{user}{screen_name} . ' ');
        $status = "\@$statuses->[$in]->{user}{screen_name} $status";
        $self->update($statuses->[$in]->{id}, $status);
    }
    elsif ($in =~ m/^w\d+$/) {
        $in =~ s/w//;
        my $screen_name = $statuses->[$in]->{user}{screen_name};
        $self->show_user($screen_name);
    }
    elsif (my ($k) = $in =~ m/^([rt])\d+$/) {
        $in =~ s/$k//;
        say "RT to: \@$statuses->[$in]->{user}{screen_name}: " . utf->encode($statuses->[$in]->{text});
        my $status = $self->term->readline('str: ');
        $status = $status . " RT @" . utf->encode("$statuses->[$in]->{user}{screen_name}: $statuses->[$in]->{text}");
        $k eq 't' ? $self->update($status) : $self->update($statuses->[$in]->{id}, $status);
    }
    elsif ($in =~ m/^f\d+$/) {
        $in =~ s/f//;
        my $reply_id = $statuses->[$in]->{in_reply_to_status_id};
        if ($reply_id) {
            my $status = $self->nt->show_status({id => $reply_id});
            $self->print_status([$status]);
            return $self->ask_reaction([$status]);
        }
        else {
            say "can not follow. there is no 'in_reply_to_status_id'";
        }
    }
    elsif ($in =~ m/^v\d+$/) {
        $in =~ s/v//;
        my $id = $statuses->[$in]->{id};
        my $user = $statuses->[$in]->{user}{screen_name};
        my $text = utf->encode($statuses->[$in]->{text});
        $self->nt->create_favorite($id) and return $self->done("favorite:\n$user\:$text");
    }
    elsif ($in =~ m/^s\d+$/) {
        $in =~ s/s//;
        my $screen_name = $statuses->[$in]->{user}{screen_name};
        $self->user_timeline($screen_name);
    }
    elsif ($in =~ m/^n\d+$/) {
        $in =~ s/n//;
        my $screen_name = $statuses->[$in]->{user}{screen_name};
        $self->report_spam($screen_name);
    }
    elsif ($in =~ m/^d\d+$/) {
        $in =~ s/d//;
        my $id = $statuses->[$in]->{id};
        $self->destroy_status($id);
    }
    elsif ($in =~ m/^b\d+$/) {
        $in =~ s/b//;
        my $block_name = $statuses->[$in]->{user}{screen_name};
        $self->block_user($block_name);
    }

    $self->done;
}

sub show_user {
    my ($self, $id) = @_;
    $id ||= $self->user;
    say $self->_user_info->{body} and return $self->done
        if $self->_user_info and $self->_user_info->{id} eq $id;

    my %res = %{$self->nt->show_user($id)};
    my %filterd;
    my @want = qw/id name screen_name lang url description location
                  time_zone statuses_count created_at friends_count followers_count/;
    @filterd{@want} = @res{@want};
    my $t = parse_time($filterd{created_at});
    $filterd{created_at} = join " ", $t->ymd('/'), "(@{[$t->day]})", $t->hms;

    my %user_info;
    $user_info{id} = $id;
    for my $key (@want) {
        $filterd{$key} ||= '';
        decode_entities $filterd{$key};

        $filterd{$key} =~ s/\r?\n/ /g;

        my $s1 = 55;
        my $s2 = $s1 - 15;
        if ($s1 < (length $filterd{$key})) {
            no warnings;
            my $rest = substr $filterd{$key}, 0, $s2;
            $filterd{$key} = substr $filterd{$key}, $s2;
            $rest = utf->encode($rest) if utf8::is_utf8($rest);
            my $key2 = sprintf "%-15s", $key;
            $user_info{body} .= "$key2 $rest\n";
            while ($filterd{$key}) {
                $rest = substr $filterd{$key}, 0, $s1;
                $filterd{$key} = substr $filterd{$key}, $s1;
                $rest = utf->encode($rest) if utf8::is_utf8($rest);
                $user_info{body} .= " " x 16 . "$rest\n";
            }
        }
        else {
            $filterd{$key} = utf->encode($filterd{$key}) if $filterd{$key} and utf8::is_utf8($filterd{$key});

            my $key2 = sprintf "%-15s", $key;
            $user_info{body} .= "$key2 $filterd{$key}\n";
        }
    }
    say $user_info{body};
    $self->_user_info(\%user_info) if $id eq $self->user;
    $self->done;
}

sub followers {
    my ($self, @args) = @_;

    say $self->_followers and return $self->done if $self->_followers;
    my $followers;
    $followers .= "$_->{screen_name} " for @{$self->nt->followers};
    $self->_followers($followers);
    say $self->_followers and return $self->done;
}

sub friends {
    my ($self, @args) = @_;

    say $self->_friends and return $self->done if $self->_friends;
    my $friends;
    $friends .= "$_->{screen_name} " for @{$self->nt->friends};
    $self->_friends($friends);
    say $self->_friends and return $self->done;
}

sub retweets_of_me {
    my ($self, $count) = @_;
    $count ||= $COUNT;

    $self->update_statuses;
    my $statuses = $STATUSES{retweets_of_me};
    $statuses = [map {$statuses->{$_}} reverse sort {$a <=> $b} keys %$statuses];
    $self->print_status($statuses) and $self->done;
}

sub list_memberships {
    my ($self, $screen_name) = @_;
    $screen_name ||= $self->user;
    say $self->_list_memberships and return $self->done if $self->_list_memberships;

    my $lists = $self->nt->list_memberships({user => $screen_name, cursor => -1});
    my ($_list_memberships, @list_memberships);

    my $i = 1;
    do {
        for my $list (@{$lists->{lists}}) {
            push @list_memberships, "$list->{full_name} :". utf->encode($list->{description} or '') . "\n";
        }
        my $lists_next = $self->nt->list_memberships({user => $screen_name, cursor => $lists->{next_cursor}});
        $lists = $lists->{next_cursor} ? $lists_next : undef;
    } while ($lists);

    $_list_memberships .= "list number: " . @list_memberships . "\n\n";
    $_list_memberships .= $_ for @list_memberships;
    $self->_list_memberships($_list_memberships);
    say $self->_list_memberships and return $self->done;
}

sub search {
    my ($self, @words) = @_;
    @words or return $self->done('args: word[s]');

    my $word = join "", @words;
    my $statuses = $self->nt->search({q => $word, lang => 'all'})->{results};
    $self->print_status($statuses, 1);
    $self->ask_reaction($statuses);
    $self->done;
}

sub favorites {
    my ($self, $screen_name) = @_;

    my $statuses;
    if ($screen_name) {
        $statuses = $self->nt->favorites({id => $screen_name});
    }
    else {
        $screen_name = $self->user;
        $self->update_statuses;
        $statuses = $STATUSES{favorites};
        $statuses = [map {$statuses->{$_}} reverse sort {$a <=> $b} keys %$statuses];
    }
    $self->print_status($statuses);
    $self->ask_reaction($statuses);
    $self->done;
}

sub help {
    my ($self, @args) = @_;
    say "ソース嫁" and $self->done
}

sub favs {
    my ($self, $screen_name) = @_;
    $screen_name ||= $self->user;

    say $self->_favs->{$screen_name} and $self->done
        if $self->_favs and $self->_favs->{$screen_name};

    my $favs;
    my $ua = LWP::UserAgent->new;
    my $rss = XML::RSS->new;
    my $body = $rss->parse($ua->get("http://ja.favstar.fm/users/$screen_name/rss")->decoded_content);
    for my $i (reverse @{$body->{items}}) {
        my $str = utf->encode($i->{title});
        $str =~ s/star/favs/;
        $favs .= "$str\n";
    }
    my $_favs = $self->_favs;
    $_favs->{$screen_name} = $favs;
    $self->_favs($_favs);
    say $self->_favs->{$screen_name} and $self->done;
}

sub quit {
    my ($self, @args) = @_;
    say "bye." and exit
}

package main;
use strict;
use warnings;

my $putweet = Putweet->new;
$putweet->init;
$putweet->main_loop while 1;

__DATA__
menu:
  item:
    - timeline
    - status
    - user
    - message
    - friend
    - block
    - lists
    - favorites
    - search
    - system
  contents:
    -
      -
        - f
        - home_timeline
        - count?
        - ~
      -
        - m
        - mentions
        - count?
        - ~
      -
        - s
        - user_timeline
        - id/screen_name
        - show one user's timeline
      -
        - t
        - retweets_of_me
        - count?
        - show your RTed status
    -
      -
        - a
        - show_status
        - status_id
        - show the id's status
      -
        - y
        - destroy_status
        - status_id
        - ~
      -
        - u
        - update
        - status
        - ~
    -
      -
        - i
        - friends
        - none
        - show your friends
      -
        - o
        - followers
        - none
        - show your followers
      -
        - w
        - show_user
        - user_id/screen_name?
        - show the user's info
    -
      -
        - d
        - direct_messages
        - count?
        - show your direct messages
    -
      -
        - e
        - create_friend
        - user_id/screen_name
        - ~
      -
        - r
        - destroy_friend
        - user_id/screen_name
        - ~
      -
        - x
        - rel_exists
        - screen_name{1,2}
        - ~
    -
      -
        - b
        - block_user
        - user_id/screen_name
        - ~
      -
        - k
        - unblock_user
        - user_id/screen_name
        - ~
      -
        - l
        - show_blocking
        - none
        - ~
      -
        - n
        - report_spam
        - id/screen_name
        - ~
    -
      -
        - p
        - list_memberships
        - none
        - ~
    -
      -
        - g
        - favorites
        - screen_name?
        - show your favorites
    -
      -
        - z
        - search
        - word
        - search from tweets
    -
      -
        - c
        - change_user
        - none
        - ~
      -
        - h
        - help
        - none
        - ~
      -
        - v
        - favs
        - screen_name?
        - show your favorited statuses
      -
        - q
        - quit
        - none
        - ~
